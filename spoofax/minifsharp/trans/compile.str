module compile

imports

  libstratego-gpp
  libspoofax/stratego/debug
  src-gen/signatures/-
  trans/pp
  trans/desugar
  trans/minifsharp
  
imports

rules

	
	show-cil: (selected, _, ast, path, project-path) -> (filename, result) with
	    filename := <guarantee-extension(|$[cil])> path;
		result := <desugar-all; program-to-cil; pp-debug> ast

	program-to-cil: Program(e,Let(a,b,c,d)) -> ProgramCil(<concat> [[Method(a, [], <program-to-cil> d)], <nonEntryPoints-to-cil> e], a)
	
	program-to-cil: Application(a,b) -> <debug2;concat> [<debug0;program-to-cil;debug1> a, <program-to-cil> b, [CallVirt("placeholder")]]
	
	program-to-cil: Identifier(name) -> [NewObj(<concat-strings> [name, "_0"], [])]
	
	program-to-cil: ExprBlock(exp, None()) -> <program-to-cil> exp
	program-to-cil: ExprBlock(exp, Some(next)) -> <program-to-cil> next // only last expression actually does something.. i think
	
	program-to-cil: Const(Integer(x)) -> [Ldc(x)]
	program-to-cil: BinaryOperation(op, a, b) -> <concat> [<program-to-cil> a, <program-to-cil> b, <binop-to-cil> op]
	
	program-to-cil: a @ Let(name,args,retTy,body) -> <concat> [[Method(name, <map(\x -> "int32"\)> args, <program-to-cil> body)], <curriedFunction-to-cil> ([], a)]

	program-to-cil: LetExp(a@Let(_,_,_,_)) -> <debuga;program-to-cil;debugb> a

//	curriedFunction-to-cil: Let(name, [argHead | []], retTy, body) -> []
 

	getIdentifierName: Identifier(x) -> x
	getIdentifierName: TypedIdentifier(x, _) -> x
	
	curriedFunction-to-cil: (processed, Let(name, [], retTy, body)) -> []
	
	curriedFunction-to-cil: (processed, Let(name, [argHead | argTail], retTy, body)) -> <concat> [[FunctionDefinition(
		<concat-strings> [name, "_", <length;int-to-string> processed],
		<getCurriedType> (retTy, [argHead | argTail]),
		<map(generateField)> processed,
		<generateConstructor> (<concat-strings> [name, "_", <length;int-to-string> processed], processed, <getCurriedType> (retTy, [argHead | argTail])),
		<getCurriedType> (retTy, argTail),
		<generateInvokeImplementation> (name, processed, argTail)
	)],
	<curriedFunction-to-cil> (<concat> [processed, [argHead]], Let(name, argTail, retTy, body))
	]
	
	// no more args to process; this is the final call; don't return a new function, but return the function result.
	generateInvokeImplementation: (className, processed, []) -> <concat> [
		<mapconcat(\x -> [LoadArg("0"), LoadField("int32", <concat-strings> [className, "_", <length;int-to-string> processed], <getIdentifierName>x)] \)> processed,
		[LoadArg("1"), Call("int32", <concat-strings> ["get_", className], <map(\x -> "int32"\)> [Identifier("q") | processed]), Ret()] // hack: add current param
	]
	
	generateInvokeImplementation: (className, processed, nextArgs) -> <concat> [
		<mapconcat(\x -> [LoadArg("0"), LoadField("int32", className, <getIdentifierName> x)] \)> processed,
		[LoadArg("1"), NewObj(<concat-strings> [className, "_", <addS> ("1", <length;int-to-string> processed)], <map(\x -> "int32"\)> [Identifier("bla") | processed]), Ret()] // dirty hack
 	]
//	      load all fields 
//      load param  
//      call ctor 
 
 
 	getCurriedType: (retTy, []) -> "int32"
 	getCurriedType: (retTy, [argTyHd | argTyTl]) -> <concat-strings> ["class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,", <getCurriedType> (retTy, argTyTl), ">"]
 
	generateField: x -> Field("int32", <getIdentifierName> x)
//	generateParam: 

	generateFieldInit: (idx, className, []) -> []
	generateFieldInit: (idx, className, [hd | tl]) -> <concat>[
		[
			LoadArg("0"),
			LoadArg(idx),
			StoreField("int32", className, <getIdentifierName> hd)
		],
		<generateFieldInit> (<addS>(idx, "1"), className, tl)
		]

	generateBaseInit: baseType -> <concat>[[LoadArg("0")], [CallConstructor(baseType)]]
	generateConstructorParamCopy: x -> []
	generateConstructor: (className, params, baseType) -> Ctor(
								<map(\y -> Param("int32", <getIdentifierName> y) \)> params,
								<concat> [
									<generateBaseInit> baseType,
									<generateFieldInit> ("1", className, params),
									[Ret()]
								] 
								)

	
	binop-to-cil: PlusOp() -> [Add()]
	binop-to-cil: MinOp()  -> [Sub()]
	binop-to-cil: MultOp() -> [Mul()]
	
	nonEntryPoints-to-cil: None() -> []
	nonEntryPoints-to-cil: Some(x) -> <listifyExprBlock; map(program-to-cil); concat> x
	
	listifyExprBlock: ExprBlock(exp, Some(next)) -> <concat> [[exp], <listifyExprBlock> next]
	listifyExprBlock: ExprBlock(exp, None()) -> [exp]
	
	