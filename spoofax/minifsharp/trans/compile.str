module compile

imports

  libstratego-gpp
  libspoofax/stratego/debug
  src-gen/signatures/-
  nabl2/api
  trans/pp
  trans/desugar
  trans/minifsharp
  src-gen/nabl2/static-semantics
  
imports

rules

	
	show-cil: (selected, _, ast, path, project-path) -> (filename, result) with
	    filename := <guarantee-extension(|$[cil])> path;
	      a         := <nabl2-get-ast-analysis; debug1> ast;
		result := <debug0; desugar-all; program-to-cil; pp-debug> ast

	program-to-cil: Program(e,Let(a,b,c,d)) -> ProgramCil(<concat> [[Method(a, [], <program-to-cil> d)], <nonEntryPoints-to-cil> e], a)
	
	program-to-cil: z@Application(a,b) -> result with
	funTy := <nabl2-get-ast-type;debug9> a;
	result :=  <debug2;concat> [<debug0;program-to-cil;debug1> a, <program-to-cil> b, [CallVirt(<funty-to-cil> funTy)]]
	
	funty-to-cil: Function(x,y) -> <concat-strings> ["class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,", <funty-to-cil> y, ">"]
	funty-to-cil: x -> "int32"
	
	program-to-cil: Identifier(name) -> [NewObj(<concat-strings> [name, "_0"], [])]
	
	program-to-cil: ExprBlock(exp, None()) -> <program-to-cil> exp
	program-to-cil: ExprBlock(exp, Some(next)) -> <program-to-cil> next // only last expression actually does something.. i think
	
	program-to-cil: Const(Integer(x)) -> [Ldc(x)]
	program-to-cil: BinaryOperation(op, a, b) -> <concat> [<program-to-cil> a, <program-to-cil> b, <binop-to-cil> op]
	
	program-to-cil: a @ Let(name,args,retTy,body) -> result with 
		tmp := <nabl2-get-ast-type; debugq> a;
		result := <concat> [[Method(name, <map(\x -> "int32"\)> args, <program-to-cil> body)], <debug4;curriedFunction-to-cil;debug5> (tmp, name, [], args)]

	program-to-cil: LetExp(a@Let(_,_,_,_)) -> <debuga;program-to-cil;debugb> a

//	curriedFunction-to-cil: Let(name, [argHead | []], retTy, body) -> []
 

	getIdentifierName: ArgIdentifier(x) -> x
	getIdentifierName: TypedArgIdentifier(x, _) -> x
	
	
	curriedFunction-to-cil: (_, _, _, []) -> []
	curriedFunction-to-cil: (ty@Function(x,y), name, processedArgs, nextArgs@[argHd | argTl]) -> result with
		funcName 	 := <debugc;concat-strings> [name, "_", <length;int-to-string>processedArgs];
		baseClass 	 := <debugd;funty-to-cil> ty;
		fields 		 := <debuge;map(generateField)> processedArgs;
		ctor 		 := <debugf;generateConstructor> (funcName, processedArgs, baseClass);
		retTy 		 := <debugg;funty-to-cil> y;
		instructions := <debugh;generateInvokeImplementation> (name, processedArgs, nextArgs);
		nextFunction := <debugi;curriedFunction-to-cil> (y, name, <concat> [processedArgs, [argHd]], argTl);
		result 		 := <concat> [[FunctionDefinition(funcName, baseClass, fields, ctor, retTy, instructions)], nextFunction] 
		
	// no more args to process; this is the final call; don't return a new function, but return the function result.
	generateInvokeImplementation: (className, processed, []) -> <concat> [
		<mapconcat(\x -> [LoadArg("0"), LoadField("int32", <concat-strings> [className, "_", <length;int-to-string> processed], <getIdentifierName>x)] \)> processed,
		[LoadArg("1"), Call("int32", <concat-strings> ["get_", className], <map(\x -> "int32"\)> [Identifier("q") | processed]), Ret()] // hack: add current param
	]
	
	generateInvokeImplementation: (className, processed, nextArgs) -> <concat> [
		<mapconcat(\x -> [LoadArg("0"), LoadField("int32", <concat-strings> [className, "_", <length;int-to-string> processed], <getIdentifierName> x)] \)> processed,
		[LoadArg("1"), NewObj(<concat-strings> [className, "_", <addS> ("1", <length;int-to-string> processed)], <map(\x -> "int32"\)> [Identifier("bla") | processed]), Ret()] // dirty hack
 	]
//	      load all fields 
//      load param  
//      call ctor 
 
 
 	getCurriedType: (retTy, []) -> "int32"
 	getCurriedType: (retTy, [argTyHd | argTyTl]) -> <concat-strings> ["class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,", <getCurriedType> (retTy, argTyTl), ">"]
 
	generateField: x -> Field("int32", <getIdentifierName> x)
//	generateParam: 

	generateFieldInit: (idx, className, []) -> []
	generateFieldInit: (idx, className, [hd | tl]) -> <concat>[
		[
			LoadArg("0"),
			LoadArg(idx),
			StoreField("int32", className, <getIdentifierName> hd)
		],
		<generateFieldInit> (<addS>(idx, "1"), className, tl)
		]

	generateBaseInit: baseType -> <concat>[[LoadArg("0")], [CallConstructor(baseType)]]
	generateConstructorParamCopy: x -> []
	generateConstructor: (className, params, baseType) -> Ctor(
								<map(\y -> Param("int32", <getIdentifierName> y) \)> params,
								<concat> [
									<generateBaseInit> baseType,
									<generateFieldInit> ("1", className, params),
									[Ret()]
								] 
								)

	
	binop-to-cil: PlusOp() -> [Add()]
	binop-to-cil: MinOp()  -> [Sub()]
	binop-to-cil: MultOp() -> [Mul()]
	
	nonEntryPoints-to-cil: None() -> []
	nonEntryPoints-to-cil: Some(x) -> <listifyExprBlock; map(program-to-cil); concat> x
	
	listifyExprBlock: ExprBlock(exp, Some(next)) -> <concat> [[exp], <listifyExprBlock> next]
	listifyExprBlock: ExprBlock(exp, None()) -> [exp]
	
	
