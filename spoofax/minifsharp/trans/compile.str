module compile

imports

  libstratego-gpp
  libspoofax/stratego/debug
  src-gen/signatures/-
  nabl2/api
  trans/pp
  trans/desugar
  trans/minifsharp
  src-gen/nabl2/static-semantics
  

rules

	
	show-cil: (selected, _, ast, path, project-path) -> (filename, result) with
	    filename := <guarantee-extension(|$[cil])> path;
	      a         := <nabl2-get-ast-analysis; debug1> ast;
		result := <debug0; desugar-all; program-to-cil; pp-debug> ast

	program-to-cil: Program(e,l@Let(a,b,c,d)) -> ProgramCil(<concat> [[Method("int32", a, None(), [], <program-to-cil> (d, l))], <nonEntryPoints-to-cil> e], a)
	
	
	
	// For Application(a,b) we need to distinguish two cases: say there is a function f with 2 args. 
	// Case 1: application is on f with 1 arg: a resolves to a let binding. We need to pass extra params to the constructor here.
	// Case 2: application is on already curried; a does nont resolve to a let binding. No extra params in constructor.
	
	// case 1:
	program-to-cil: (z@Application(a@Identifier(name),b), func) -> result with
		q         := <nabl2-get-ast-analysis;debugx> name;
		ref-occ   := <nabl2-mk-occurrence(|"Funcs");debugy> name;
		dec-occ   := <nabl2-get-resolved-name(|q); Fst; debugz> ref-occ;
		bzzz := <nabl2-get-type(|q);debug(|"zom3 ")> dec-occ;
		brrr := <debug(|"...1 ");getFreeVars;debug(|"...2 ")> ([], bzzz);
		bfff := <debug(|"...3 ");map(nabl2-get-ast-type);debug(|"...4 ")> brrr;
		bqqq := <debug(|"...5 ");mapconcat(\x->(x, func)\;program-to-cil);debug(|"...6 ")> brrr;
		
		blll := <concat> [bqqq, [NewObj(<concat-strings> [name, "_0"], <map(type-to-cil)> bfff)]];
		funTy := <nabl2-get-ast-type;strip-forall> a;
		argTy := <nabl2-get-ast-type;strip-forall> b;
		result :=  <debug2;concat> [blll, <debugq;program-to-cil;debugw> (b, func), [CallVirt(<type-to-cil> funTy)]]
	
	
	program-to-cil: (z@Application(a,b), func) -> result with
		funTy := <nabl2-get-ast-type;strip-forall> a;
		argTy := <nabl2-get-ast-type;strip-forall> b;
		result :=  <debug2;concat> [<debug0;program-to-cil;debug1> (a, func), <debugq;program-to-cil;debugw> (b, func), [CallVirt(<type-to-cil> funTy)]]
	
	type-to-cil: Forall(_, y) -> <debugk;type-to-cil;debugl> y
	type-to-cil: Function(x,y) -> <concat-strings> ["class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<", <type-to-cil> x, ",", <type-to-cil> y, ">"]
	type-to-cil: Int() -> "int32"
	type-to-cil: Bool() -> "bool"
	type-to-cil: Tuple(x) -> <concat-strings> ["class [mscorlib]System.Tuple`", <length;int-to-string>x, "<", <separate-by;concat-strings> (",", <map(type-to-cil)> x), ">"]
	type-to-cil: List(x) -> <concat-strings> ["class [FSharp.Core]Microsoft.FSharp.Collections.FSharpList`1<", <type-to-cil> x, ">"]
	type-to-cil: TVar(x) -> <concat-strings> ["!!", x]
	
	arg-type-to-cil: (Forall(_,x), argName, args) -> <arg-type-to-cil> (x, argName, args)
	arg-type-to-cil: (Function(x,y), argName, [ArgIdentifier(argName) | _]) -> <type-to-cil> x
	arg-type-to-cil: (Function(x,y), argName, [TypedArgIdentifier(argName,_) | _]) -> <type-to-cil> x
	arg-type-to-cil: (Function(x,y), argName, [_ | argTl]) -> <arg-type-to-cil> (y, argName, argTl)
	
	ret-type-to-cil: Function(x,y) -> <ret-type-to-cil> y
	ret-type-to-cil: x -> <type-to-cil> x
	
	sort-typevars: x -> <sort-list(LSort(\(a,b) -> <gtS>(<string-replace(|"T","")> a, <string-replace(|"T","")> b)\))> x
	getGenericVarList: x -> <collect-all(?TVar(_));map(\TVar(z) -> z\); sort-typevars> x
	genericVarListToOption: [] -> None()
	genericVarListToOption: x -> Some(GenericTypeIndicator(x))
	getOptionalGenericVars: x -> <getGenericVarList; genericVarListToOption> x
	
	
	getLetArgs: Let   (_, args, _, _) -> args
	getLetArgs: LetRec(_, args, _, _) -> args
	
	
	
	// todo: return absolute index (Func(args, freeVars))
	getArg: (name, func) -> result with
		tmp := <getFreeVars> ([], func);
		idx := <debug(|"test3: ");getFreeVarIndex;debug(|"test4: ")> (tmp, name);
		idx2 := <debug(|"test5: ");getFreeVarIndex;debug(|"test6: ")> (<getLetArgs>func, name);
		if <lt> (idx, 0) then result := idx2 else  result := <add> (<getLetArgs;length> func, idx) end

	program-to-cil: (v@Identifier(name), func) -> result with 
		testz := <debug(|"test1: ");getArg;debug(|">>>>test2: ")> (v,func);
		result := [LoadArg(<int-to-string> testz)]
	
	program-to-cil: (ExprBlock(exp, None()), func) -> <program-to-cil> (exp, func)
	program-to-cil: (ExprBlock(exp, Some(next)), func) -> <concat> [<program-to-cil> (exp, func), <program-to-cil> (next, func)]
	
	program-to-cil: (Const(Integer(x)), func) -> [Ldc(x)]
	program-to-cil: (BinaryOperation(op, a, b), func) -> <concat> [<program-to-cil> (a, func), <program-to-cil> (b, func), <binop-to-cil> op]
	
	program-to-cil: (Let(_,_,_,_), func) -> [] // required for nested lets; can't have a function definition in a function body
	
	let-to-cil: a @ Let(name,args,retTy,body) -> result with 
		tmp 	   	 := <nabl2-get-ast-type; strip-forall; debugq> a;
		returnType 	 := <debug(|"retTy inp: ");ret-type-to-cil;debug(|"retTy out: ")> tmp;
		argTypes 	 := <map(\x -> <debugz;arg-type-to-cil;debugx> (tmp, <getIdentifierName> x, args)\)> args;
		genericTypes := <debug(|"baz: ");getOptionalGenericVars;debug(|"baq: ")> tmp;
		freeVars 	 := <debug(|"baz11: ");getFreeVars;debug(|"baz22: ")> ([], a);
		freeVarTypes := <map(nabl2-get-ast-type; strip-forall; type-to-cil)> freeVars;
		allArgTypes  := <concat>  [argTypes, freeVarTypes];
		method 		 := Method(returnType, name, genericTypes, allArgTypes, <program-to-cil> (body, a)); // todo: add freevar args
//		freeVars 	 := <debug(|"###1 ");getFreeVars; debug(|"###2 ")> ([], a);
		curriedFunc  := <debug4;curriedFunction-to-cil;debug5> (tmp, tmp, name, [], args, freeVars);
		result 	 	 := <concat;debug6> [[method], curriedFunc, <listifyExprBlock;mapconcat(let-to-cil)> body]
	let-to-cil: _ -> []


	strip-forall: Forall(x,y) -> y
	strip-forall: x -> x
 
	getIdentifierName: ArgIdentifier(x) -> x
	getIdentifierName: TypedArgIdentifier(x, _) -> x
	getIdentifierName: Identifier(x) -> x
	getIdentifierName: Let(name, _, _, _)    -> name // required for getExprBlockArgs (bit of a dirty hack..)
	getIdentifierName: LetRec(name, _, _, _) -> name // required for getExprBlockArgs
	getIdentifierName: LetConst(name, _, _)  -> name // required for getExprBlockArgs
	
	
	curriedFunction-to-cil: (_, _, _, _, [], freeVars) -> []
	curriedFunction-to-cil: (funTy, ty@Function(x,y), name, processedArgs, nextArgs@[argHd | argTl], freeVars) -> result with
		funcName 	 := <debugc;concat-strings> [name, "_", <length;int-to-string>processedArgs];
		baseClass 	 := <debugd;type-to-cil> ty;
		all_fields   := <concat> [processedArgs, freeVars];
		fields 		 := <debuge;map(generateField)> all_fields;
		ctor 		 := <debugf;generateConstructor> (funcName, processedArgs, baseClass, freeVars);
		retTy 		 := <debugg;type-to-cil> y;
		instructions := <debugh;generateInvokeImplementation> (funTy, name, processedArgs, argTl, freeVars);
		genericVars  := <getOptionalGenericVars> funTy;
		function     := FunctionDefinition(funcName, genericVars, baseClass, fields, ctor, retTy, instructions);
		nextFunction := <debugi;curriedFunction-to-cil> (funTy, y, name, <concat> [processedArgs, [argHd]], argTl, freeVars);
		result 		 := <concat> [[function], nextFunction] 
		
		
	loadArg: (processed, funTy, className, x) -> result with 
		fldType := <debugm;arg-type-to-cil;debugn> (funTy,<getIdentifierName>x, processed);
		cName 	:= <debugo;concat-strings> [className, "_", <length;int-to-string> processed];
		fldName := <getIdentifierName> x;
		result := [LoadArg("0"), LoadField(fldType, cName, fldName)] 
	loadArgs: (processed, funTy, className) -> <mapconcat(\x -> <loadArg> (processed, funTy, className, x)\)> processed

	loadFreeVar: (className, freeVar) -> result with
		ty        := <nabl2-get-ast-type; type-to-cil> freeVar;
		fieldName := <getIdentifierName> freeVar;
		result    := [LoadArg("0"), LoadField(ty, className, fieldName)]
	loadFreeVars: (className, freeVars) -> result with
		result := <debug(|"~~~1 ");mapconcat(\x -> (className, x)\; loadFreeVar; debug(|"~~~1 "))> freeVars
	
	// no more args to process; this is the final call; don't return a new function, but return the function result.
	generateInvokeImplementation: (funTy, className, processed, [], freeVars) -> result with 
//		q := <mapconcat(\x -> [LoadArg("0"), LoadField(<arg-type-to-cil> (funTy,<getIdentifierName>x,processed), <concat-strings> [className, "_", <length;int-to-string> processed], <getIdentifierName>x)] \)> processed;
		loadCurriedArgs := <loadArgs> (processed, funTy, className);
		loadFreeVars := <loadFreeVars> (<debugo;concat-strings> [className, "_", <length;int-to-string> processed], freeVars);
//		funcArgs := 
		argTys := <debug(|"@@@3 ");map(\x -> "int32"\)> [Identifier("q") | processed];
		freeVarTys := <debug(|"@@@1 "); map(nabl2-get-ast-type;type-to-cil);debug(|"@@@2 ")> freeVars;
		tys := <concat> [argTys, freeVarTys];
		funcName := <concat-strings> ["get_", className];
		result := <concat> [
			loadCurriedArgs,
			[LoadArg("1")], // load the argument of this invoke
			loadFreeVars,
			[Call(<debug2;ret-type-to-cil> funTy, funcName, tys), Ret()] // hack: add current param
		]
	
	generateInvokeImplementation: (funTy, className, processed, nextArgs, freeVars) -> result with
		loadCurriedArgs := <loadArgs> (processed, funTy, className);
		loadFreeVars := <loadFreeVars> (<debugo;concat-strings> [className, "_", <length;int-to-string> processed], freeVars);
		argTys := <debug(|"@@@3 ");map(\x -> "int32"\)> [Identifier("q") | processed];       // todo: remove this dirty hack
		freeVarTys := <debug(|"@@@1 "); map(nabl2-get-ast-type;type-to-cil);debug(|"@@@2 ")> freeVars;
		tys := <concat> [argTys, freeVarTys];
		createObj := NewObj(<concat-strings> [className, "_", <addS> ("1", <length;int-to-string> processed)], tys); 
		result := <concat> [
			loadCurriedArgs,
			[LoadArg("1")],
			loadFreeVars,
			[createObj] 
	 	]
 
 	getCurriedType: (retTy, []) -> "int32"
 	getCurriedType: (retTy, [argTyHd | argTyTl]) -> <concat-strings> ["class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<int32,", <getCurriedType> (retTy, argTyTl), ">"]
 
 
 	// a field is a param, but named differently..
	generateField: x -> <generateParam; \Param(a,b) -> Field(a,b)\> x

	generateFieldInit: (idx, className, []) -> []
	generateFieldInit: (idx, className, [Param(ty,name) | tl]) -> <concat>[
		[
			LoadArg("0"),
			LoadArg(idx),
			StoreField(ty, className, name)
		],
		<generateFieldInit> (<addS>(idx, "1"), className, tl)
		]

	generateBaseInit: baseType -> <concat>[[LoadArg("0")], [CallConstructor(baseType)]]
	generateConstructorParamCopy: x -> []
	generateParam: x -> result with
		ty     := <nabl2-get-ast-type;strip-forall;type-to-cil> x;
		name   := <getIdentifierName> x;
		result := Param(ty, name)
	generateConstructor: (className, params, baseType, freeVars) -> result with 
		curried_params := <map(generateParam)> params;
		freeVar_params := <debug(|"q1: ");map(generateParam);debug(|"q3: ")> freeVars;
		all_params     := <concat> [curried_params, freeVar_params];
		body 		   := <concat> 
		[
			<generateBaseInit> baseType,
			<generateFieldInit> ("1", className, all_params),
			[Ret()]
	    ];
		result := Ctor(all_params, body)

	
	binop-to-cil: PlusOp() -> [Add()]
	binop-to-cil: MinOp()  -> [Sub()]
	binop-to-cil: MultOp() -> [Mul()]
	
	nonEntryPoints-to-cil: None() -> []
	nonEntryPoints-to-cil: Some(x) -> <listifyExprBlock; map(let-to-cil); concat> x
	
	listifyExprBlock: ExprBlock(exp, Some(next)) -> <concat> [[exp], <listifyExprBlock> next]
	listifyExprBlock: ExprBlock(exp, None()) -> [exp]
	
	
	
	getFreeVars: (scope, None()) -> [] 
	getFreeVars: (scope, Some(x)) -> <getFreeVars> (scope, x)
	getFreeVars: (scope, ExprBlock(exp, tail)) -> <concat> [<getFreeVars> (scope, exp), <getFreeVars> (<concat> [scope, args], tail)] with 
		args := <getExprBlockArgs> (scope, exp)
	getFreeVars: (scope, BinaryOperation(op, a, b)) -> <concat> [<getFreeVars> (scope, a), <getFreeVars> (scope, b)]
	getFreeVars: (scope, Const(_)) -> []
	getFreeVars: (scope, x@Identifier(_)) -> <debug(|"b1: ");getFreeVar;debug(|"werkt niet: ")> (scope, x)
	getFreeVars: (scope, Application(a,b)) -> <concat> [<getFreeVars> (scope, a), <getFreeVars> (scope, b)]
	getFreeVars: (scope, Let(name,args,retTy,body)) -> <getFreeVars> (newscope, body) with
		argscope :=  args;
		newscope := <debug(|"blabla: ");concat;debug(|"nieuw scopie: ")> [argscope, scope]
	
	getExprBlockArgs: (scope, l@Let(_, _, _, _)) -> [l]
	getExprBlockArgs: (scope, l@LetRec(_, _, _, _)) -> [l]
	getExprBlockArgs: (scope, l@LetConst(_, _, _)) -> [l]
	getExprBlockArgs: (scope, _) -> []
	
	
	indexOf: ([], var, idx) -> None()
	indexOf: ([var | tl], var, idx) -> idx
	indexOf: ([_   | tl], var, idx) -> <indexOf> (tl, var, <add> (idx, 1))
	
		
	getFreeVarIndex: (vars, var) -> result with
		var_names := <debug(|"b3: ");map(getIdentifierName;strip-annos);debug(|"b4: ")> vars;
		var_name  := <debug(|"b5: ");getIdentifierName;strip-annos> var;
		result 	  := <indexOf> (var_names, var_name, 0)
		
	getFreeVar: (vars, var) -> result with 
		var_names := <debug(|"b3: ");map(getIdentifierName);debug(|"b4: ")> vars;
		var_name := <debug(|"b5: ");getIdentifierName;debug(|"b6: ")> var;
		if <strip-annos;elem> (var_name, var_names) then result := [] else result := [var] end
 
		