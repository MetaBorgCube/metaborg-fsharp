module static-semantics

imports

  signatures/-

signature

  
  constructors
    Int : Type
    Bool : Type
    
  name resolution

    labels
      P I

    order
      D < I,
      D < P,
      I < P

    well-formedness
	  (P* . I*)

rules

  init ^ (s) := new s.

  [[ Program(expBlock, main) ^ (s) ]] :=
	new mainscope,
	new mainscopeinside,
	mainscopeinside -P-> mainscope,
  	ProgramExp [[ expBlock ^ (s, mainscope) : ty]],
  	[[ main ^ (mainscope,  mainscopeinside) : ty2]],
  	true.

  ProgramExp[[ Some(block @ ExprBlock(_, _)) ^ (s, mainscope) : ty ]] :=
  	ProgramExp[[ block ^ (s, mainscope) : ty]].
  	
  ProgramExp[[ None() ^ (s, mainscope) : ty ]] :=
    mainscope -P-> s,
    true.
	
  ProgramExp[[ ExprBlock(LetExp(x), next) ^ (s, mainscope) : ty ]] := 
  	new s',
  	s' -P-> s,
	[[ x ^ (s, s') : ty1]],
	ProgramExp[[ next ^ (s', mainscope) : ty2 ]].
	
  ProgramExp[[ ExprBlock(exp, next) ^ (s, mainscope) : ty ]] := 
	[[ exp ^ (s) : ty1 ]],
	ProgramExp[[ next ^ (s, mainscope) : ty2 ]].
	
  [[ ExprBlock(exp, None()) ^ (s) : ty]] := 
	[[ exp ^ (s) : ty ]].
	
  [[ ExprBlock(exp, Some(next)) ^ (s) : ty]] := 
	[[ exp ^ (s) : ty1 ]],
	[[ next ^ (s) : ty ]].

  [[ Let(id, args, retTy, body) ^ (s, s') : (argTys, retTyp) ]] := 
	Const{id} <- s',
	Const{id} : (argTys, retTyp),
	new s_body, 
	s_body -P-> s,
	Map1T(CheckParam) [[ args ^ (s_body) : argTys ]], // constraint of the arg types
	GetSpecifiedRetTy [[ retTy ^ (s) : retTyp ]],	  // Constraint of the specified type
    [[ body ^ (s_body) : retTyp]].					  // Constraint of the infered type
    
  [[ LetConst(id, retTy, body) ^ (s, s') : ty ]] := 
	Const{id} <- s',
	Const{id} : (argTys, retTyp),
	new s_body, 
	s_body -P-> s,
	GetSpecifiedRetTy [[ retTy ^ (s) : ty ]],	  // Constraint of the specified type
    [[ body ^ (s_body) : ty]].					  // Constraint of the infered type
    
  // funtion parameters
    
  CheckParam [[ Identifier(id) ^ (s) : ty ]] := 
    Const{id} <- s,
    Const{id} : ty.
  CheckParam [[ TypedIdentifier(id, typ) ^ (s) : ty ]] := 
  	GetType [[ typ ^ (s) : ty ]],
  	Const{id} <- s,
  	Const{id} : ty.
  
  // Function return types
   
  GetSpecifiedRetTy [[ None() ^ (s) : ty ]] := true.		 // No return type specified; no additional constraint
  GetSpecifiedRetTy [[ Some(ReturnType(x)) ^ (s) : ty ]] :=  // Additional constraint: the function should return the specified type
  	GetType [[ x ^ (s) : ty ]].
   
  // Get specified type
  
  GetType [[ Integer() ^ (s) : Int() ]] := true.
  GetType [[ Boolean() ^ (s) : Bool() ]] := true.
    
  [[ LetRec(id, args, retTy, body) ^ (s, s') ]] := 
	Const{id} <- s',
    [[ body ^ (s') ]].

  [[ Identifier(id) ^ (s) : ty]] :=
  	Const{id} -> s, 
  	Const{id} |-> d,
  	d : ty.
  
  [[ Const(v) ^ (s) : ty]] :=
    [[ v ^ (s) : ty]].
  
  [[ Integer(x) ^ (s) : Int()]] :=
   true.
   
  [[ Bool(x) ^ (s) : Bool()]] :=
   true.
   
  [[ BinaryOperation(PlusOp(), a,b) ^ (s) : Int()  ]] := [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
  [[ BinaryOperation(MinOp() , a,b) ^ (s) : Int()  ]] := [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
  [[ BinaryOperation(MultOp(), a,b) ^ (s) : Int()  ]] := [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
  [[ BinaryOperation(AndOp(),  a,b) ^ (s) : Bool() ]] := [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
  [[ BinaryOperation(OrOp(),   a,b) ^ (s) : Bool() ]] := [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
  [[ BinaryOperation(ConcatOp(), a,b) ^ (s) : ty ]] := [[ a ^ (s) : c ]], [[ b ^ (s) : c ]].          // todo

  [[ Application(e1, e2) ^ (s) : (otherArgTys, funcRetTy) ]] := 
    [[ e1 ^ (s) : ([argTy | otherArgTys], funcRetTy) ]],
    [[ e2 ^ (s) : argTy ]].
  
    
    
