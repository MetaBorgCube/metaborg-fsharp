module static-semantics

imports

  	signatures/-

signature

  	constructors
    	Int : Type
    	Bool : Type
    	List : Type -> Type
    	Tuple : list(Tuple) -> Type
    	Function : Type * Type -> Type
    	Forall : list(Var) * Term -> Term
    	TVar : String -> Term
    	Origin : String
    	UnionType : String -> Type
    	
  	name resolution

    labels
      	P I

    order
      	D < I,
      	D < P,
      	I < P

    well-formedness
	  	(P* . I*)
	  
rules

  	init ^ (s) := new s.

	// Program Rules

  	[[ Program(expBlock, main) ^ (s) ]] :=
		new mainscope,
  		ProgramExp [[ expBlock ^ (s, mainscope) : ty]],
		new mainscope',
    	mainscope' -P-> mainscope,
  		[[ main ^ (mainscope, mainscope') : ty2]],
  		true.

  	ProgramExp[[ Some(block @ ExprBlock(_, _)) ^ (s, mainscope) : ty ]] :=
  		OuterExprBlock[[ block ^ (s, _, mainscope) : ty]].
  	
  	ProgramExp[[ None() ^ (s, mainscope) : ty ]] :=
    	mainscope -P-> s.
	
	// Expression Block Rules

	OuterExprBlock[[ a@ExprBlock(exp, None()) ^ (s, _, mainscope) : ty]] := 
		new s',
		s' -P-> s,
		ExprBlock2 [[ a ^ (s, s', _) : ty ]],
		mainscope -P-> s'.
	
  	OuterExprBlock[[ a@ExprBlock(exp, Some(next)) ^ (s, _, mainscope) : ty]] := 
		new s',
		s' -P-> s,
		ExprBlock2 [[ a ^ (s, s', _) : ty ]],
		OuterExprBlock[[ next ^ (s', _, mainscope) : ty ]].
	
  	InnerExprBlock[[ a@ExprBlock(exp, None()) ^ (s, _, _) : ty]] := 
		new s',
		s' -P-> s,
		ExprBlock2 [[ a ^ (s, s', _) : ty ]].
	
  	InnerExprBlock[[ a@ExprBlock(exp, Some(next)) ^ (s, _, _) : ty]] := 
		new s',
		s' -P-> s,
		ExprBlock2 [[ a ^ (s, s', _) : ty ]],
		InnerExprBlock[[ next ^ (s', _, _) : ty ]].

	ExprBlock2[[ ExprBlock(a@Let(_, _, _, _, _), _) ^ (s, s', _) : ty ]] :=
		[[ a ^ (s, s') : ty ]].
	ExprBlock2[[ ExprBlock(a@LetConst(_, _, _), _) ^ (s, s', _) : ty ]] :=
		[[ a ^ (s, s') : ty ]].
	ExprBlock2[[ ExprBlock(a, _) ^ (s, s', _) : ty ]] :=
		[[ a ^ (s) : ty ]].

	// Let Rules

  	[[ a@Let(NonRecursive(), id, args, retId, body) ^ (s, s') : argCurried2 ]] := 
		GetSpecifiedRetTy [[ retId ^ (s_body) : retTyp ]],
		new s_body, 
		s_body -P-> s,
	    InnerExprBlock[[ body ^ (s_body, _, _) : retTyp]],
		MapCurry [[ args ^ (s_body, retTyp) : argCurried ]],
		argCurried2 genOf(vars) argCurried,
		Const{id}.origin := a, 
		Const{id} <- s',
		Const{id} : argCurried2.
	  
  	[[ a@Let(Recursive(), id, args, retId, body) ^ (s, _) : argCurried2 ]] := 
    	GetSpecifiedRetTy [[ retId ^ (s_body) : retTyp ]],
		MapCurry [[ args ^ (s_body, retTyp) : argCurried ]],
		argCurried2 genOf(vars) argCurried,
		new s_body, 
		s_body -P-> s,
		Const{id}.origin := a, 
		Const{id} <- s,
		Const{id} : argCurried2,
	    InnerExprBlock[[ body ^ (s_body, _, _) : retTyp]].
    
  	[[ a@LetConst(id, retTy, body) ^ (s, s') : ty ]] := 
		GetSpecifiedRetTy [[ retTy ^ (s_body) : ty ]],
		new s_body, 
		s_body -P-> s,
		Const{id}.origin := a, 
		Const{id} <- s',
		Const{id} : ty,
	    InnerExprBlock[[ body ^ (s_body, _, _) : ty]].
    
    // Match Rules
    
    [[ Match(id, rules) ^ (s) : ty ]] :=
    	[[ id ^ (s) : idType ]],
    	Map2UT [[ rules ^ (s, idType) : ty ]].
    	
    [[ Rule(pattern, body) ^ (s, idType) : ty ]] :=
		new s_body, 
		s_body -P-> s,
    	Pattern [[ pattern ^ (s_body) : idType ]],
    	[[ body ^ (s_body) : ty ]].
    	
    // Pattern Rules
    
    Pattern [[ Wildcard() ^ (s) : ty ]].
    
    Pattern [[ PatternOr(p1, p2) ^ (s) : ty ]] :=
    	Pattern [[ p1 ^ (s) : ty ]],
    	Pattern [[ p2 ^ (s) : ty ]].
    	
	Pattern [[ EmptyPatternList() ^ (s) : ty ]].
    	
    Pattern [[ PatternConcat(p1, p2) ^ (s) : List(ty) ]] :=
    	Pattern [[ p1 ^ (s) : ty ]],
    	Pattern [[ p2 ^ (s) : List(ty) ]].
    	
	Pattern [[ PatternTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T(Pattern) [[ plist ^ (s) : ty]].
		
	Pattern [[ TypeConstruct(id, arg) ^ (s) : funcRetTy ]] :=
		Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : constructTy,
	    ty2 instOf constructTy,
	    Pattern [[ arg ^ (s) : argTy ]],
	    ty2 == Function(argTy, funcRetTy).
	    
	Pattern [[ a@Const(_) ^ (s) : ty]] :=		[[ a ^ (s) : ty]].
  	Pattern [[ a@Integer(_) ^ (s) : Int()]] :=	[[ a ^ (s) : ty]].
   	Pattern [[ a@Bool(_) ^ (s) : Bool() ]] :=	[[ a ^ (s) : ty]].
	
  	Pattern [[ a@Identifier(id) ^ (s) : ty]] :=
  		Const{id}.origin := a, 
		Const{id} <- s,
		Const{id} -> s, 
	  	Const{id} |-> d,
		Const{id} : ty.
    
    // Union types
    
    [[ TypeDefinition(id, Union(alist)) ^ (s) : UnionType(id) ]] :=
    	Map1UT(TypeEscaped) [[ alist ^ (s) : UnionType(id) ]],
		Const{id} <- s,
		Const{id} : UnionType(id).
    	
    TypeEscaped [[ a@TypedID(id, type) ^ (s) : unionTy ]] :=
    	[[ type ^ (s) : ty ]],
		Const{id} <- s,
		Const{id}.origin := a,
		Const{id} : Function(ty, unionTy).
		
    TypeEscaped [[ TypeConstIdentifier(id) ^ (s) : unionTy ]] :=
		Const{id} <- s,
		Const{id} : unionTy.
		
	// Type parameters
    
    [[ TypeDefinition(id, def) ^ (s) : ty ]] :=
		[[ def ^ (s) : ty ]],
		Const{id} <- s,
		Const{id} : ty.
    [[ SingleType(t) ^ (s) : ty ]] := [[ t ^ (s) : ty ]].
    [[ IntegerType() ^ (s) : Int() ]].
    [[ BooleanType() ^ (s) : Bool() ]].
    [[ ListType(t) ^ (s) : List(ty) ]] := [[ t ^ (s) : ty ]].
	[[ TypeTuple(plist) ^ (s) : Tuple(ty) ]] := Map1T [[ plist ^ (s) : ty]].
		
  	// Function return types
   
	GetSpecifiedRetTy [[ None() ^ (s) : ty ]] := true.		 	// No return type specified; no additional constraint
	GetSpecifiedRetTy [[ Some(ReturnType(x)) ^ (s) : ty ]] :=  	// Additional constraint: the function should return the specified type
  		[[ x ^ (s) : ty ]].

	// Expressions and Values
	
  	[[ Identifier(id) ^ (s) : ty]] :=
	  	Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : ty.
	
  	[[ TypeConstIdentifier(id) ^ (s) : ty]] :=
	  	Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : ty.
  
  	[[ a@Argument(id, None()) ^ (s) : ty ]] := 
	    Const{id} <- s,
	    Const{id} : ty,
	    Const{id}.origin := a.
	    
  	[[ a@Argument(id, Some(typ)) ^ (s) : ty ]] := 
  		[[ typ ^ (s) : ty ]],
	  	Const{id} <- s,
	  	Const{id} : ty,
	  	Const{id}.origin := a.
  		
  	[[ Const(v) ^ (s) : ty]] := [[ v ^ (s) : ty]].
  	[[ Integer(x) ^ (s) : Int()]].
   	[[ Bool(x) ^ (s) : Bool() ]].
		
	[[ EmptyList() ^ (s) : ty ]].
        	
	[[ ExpTuple(plist) ^ (s) : Tuple(ty) ]] := Map1T [[ plist ^ (s) : ty]].
   
	[[ BinaryOperation(PlusOp(), 		a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MinOp() , 		a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MultOp(), 		a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(EqualOp(), 		a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : ty  ]],    [[ b ^ (s) : ty  ]].
	[[ BinaryOperation(SmallerOp(), 	a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(AndOp(),  		a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(OrOp(),   		a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ Concat(							a,b) ^ (s) : List(ty) ]] 	:= [[ a ^ (s) : ty ]], 	   [[ b ^ (s) : List(ty) ]].
	
	[[ UnaryOperation(NotOp(),   		a) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]].
	[[ UnaryOperation(NegativeOp(), 	a) ^ (s) : Int() ]] 		:= [[ a ^ (s) : Int() ]].

	// Application type

	[[ Application(x@Identifier(_), e2) ^ (s) : funcRetTy ]] := 
	    [[ x ^ (s) : ty ]],
	    ty2 instOf ty,
	    ty2 == Function(argTy, funcRetTy),
	    [[ e2 ^ (s) : argTy ]].
  
  	[[ Application(e1, e2) ^ (s) : funcRetTy ]] := 
	    [[ e1 ^ (s) : Function(argTy, funcRetTy) ]],
	    [[ e2 ^ (s) : argTy ]].
  
  	// Custom Map rules for unappended types
  	
  	Map1UT[[ xs ^ (s1) : ty ]] := 
  		Map1UT(default)[[ xs ^ (s1) : ty ]].
	
	Map1UT(X)[[ [x|xs] ^ (s1) : ty ]] :=
		X[[ x ^ (s1) : ty ]],
		Map1UT(X)[[ xs ^ (s1) : ty ]].

	Map1UT(X)[[ [] ^ (s1) : ty ]].
  	
  	Map2UT[[ xs ^ (s1,s2) : ty ]] := 
  		Map2UT(default)[[ xs ^ (s1,s2) : ty ]].
	
	Map2UT(X)[[ [x|xs] ^ (s1,s2) : ty ]] :=
		X[[ x ^ (s1,s2) : ty ]],
		Map2UT(X)[[ xs ^ (s1,s2) : ty ]].

	Map2UT(X)[[ [] ^ (s1,s2) : ty ]].
	
	MapCurry [[ [x|[]] ^ (s, retTy) : Function(argType, retTy) ]] :=
		[[ x ^ (s) : argType ]].
		
	MapCurry [[ [x|xs] ^ (s, retTy) : Function(argType, ty) ]] :=
		[[ x ^ (s) : argType ]],
		MapCurry [[ xs ^ (s, retTy) : ty ]].
	
