module static-semantics

imports

  	signatures/-

signature

  	constructors
    	Int : Type
    	Bool : Type
    	Unit : Type
    
  	name resolution

    labels
      	P I

    order
      	D < I,
      	D < P,
      	I < P

    well-formedness
	  	(P* . I*)
	  
 functions
  	
  	simplifyApplicationType : Type -> Type {
  		([], retTy) -> retTy,
  		x -> x
  	}
    
rules

  	init ^ (s) := new s.

	// Program Rules

  	[[ Program(expBlock, main) ^ (s) ]] :=
		new mainscope,
		new mainscopeinside,
		mainscopeinside -P-> mainscope,
  		ProgramExp [[ expBlock ^ (s, mainscope) : ty]],
  		[[ main ^ (mainscope,  mainscopeinside) : Unit()]],
  		true.

  	ProgramExp[[ Some(block @ ExprBlock(_, _)) ^ (s, mainscope) : ty ]] :=
  		ProgramExp[[ block ^ (s, mainscope) : ty]].
  	
  	ProgramExp[[ None() ^ (s, mainscope) : ty ]] :=
    	mainscope -P-> s,
    	true.
	
  	ProgramExp[[ ExprBlock(LetExp(x), next) ^ (s, mainscope) : ty ]] := 
  		new s',
  		s' -P-> s,
		[[ x ^ (s, s') : ty1]],
		ProgramExp[[ next ^ (s', mainscope) : ty2 ]].
	
  	ProgramExp[[ ExprBlock(exp, next) ^ (s, mainscope) : ty ]] := 
		[[ exp ^ (s) : ty1 ]],
		ProgramExp[[ next ^ (s, mainscope) : ty2 ]].
	
	// Expression Block Rules
	
  	[[ ExprBlock(exp, None()) ^ (s) : ty]] := 
		[[ exp ^ (s) : ty ]].
	
  	[[ ExprBlock(exp, Some(next)) ^ (s) : ty]] := 
		[[ exp ^ (s) : ty1 ]],
		[[ next ^ (s) : ty ]].

	// Let Rules

  	[[ Let(id, args, retTy, body) ^ (s, s') : (argTys, retTyp) ]] := 
		Const{id} <- s',
		Const{id} : (argTys, retTyp),
		new s_body, 
		s_body -P-> s,
		Map1T(CheckParam) [[ args ^ (s_body) : argTys ]], // constraint of the arg types
		GetSpecifiedRetTy [[ retTy ^ (s) : retTyp ]],	  // Constraint of the specified type
	    [[ body ^ (s_body) : retTyp]].					  // Constraint of the infered type
	    
  	[[ LetRec(id, args, retTy, body) ^ (s, s') : (argTys, retTyp) ]] := 
		Const{id} <- s,
		Const{id} : (argTys, retTyp),
		new s_body, 
		s_body -P-> s,
		Map1T(CheckParam) [[ args ^ (s_body) : argTys ]], // constraint of the arg types
		GetSpecifiedRetTy [[ retTy ^ (s) : retTyp ]],	  // Constraint of the specified type
	    [[ body ^ (s_body) : retTyp]].					  // Constraint of the infered type
    
  	[[ LetConst(id, retTy, body) ^ (s, s') : ty ]] := 
		Const{id} <- s',
		Const{id} : ty,
		new s_body, 
		s_body -P-> s,
		GetSpecifiedRetTy [[ retTy ^ (s) : ty ]],	  // Constraint of the specified type
	    [[ body ^ (s_body) : ty]].					  // Constraint of the infered type
    
    // Match Rules
    
    [[ Match(id, rules) ^ (s) : ty ]] :=
    	[[ id ^ (s) : idType ]],
    	Map2UT[[ rules ^ (s, idType) : ty ]].
    	
    [[ Rule(pattern, body) ^ (s, idType) : ty ]] :=
    	[[ pattern ^ (s) : idType ]],
    	[[ body ^ (s) : ty ]].
    	
    // TODO: Pattern Rules
    
    [[ Wildcard() ^ (s) : ty ]].
    
    [[ PatternOr(p1, p2) ^ (s) : ty ]] :=
    	[[ p1 ^ (s) : ty ]],
    	[[ p2 ^ (s) : ty ]].
    
  	// Function parameters
    
  	CheckParam [[ Identifier(id) ^ (s) : ty ]] := 
	    Const{id} <- s,
	    Const{id} : ty.
  	CheckParam [[ TypedIdentifier(id, typ) ^ (s) : ty ]] := 
  	GetType [[ typ ^ (s) : ty ]],
	  	Const{id} <- s,
	  	Const{id} : ty.
  
  	// Function return types
   
	GetSpecifiedRetTy [[ None() ^ (s) : ty ]] := true.		 	// No return type specified; no additional constraint
	GetSpecifiedRetTy [[ Some(ReturnType(x)) ^ (s) : ty ]] :=  	// Additional constraint: the function should return the specified type
  		GetType [[ x ^ (s) : ty ]].
   
  	// Get specified type
  
  	GetType [[ Integer() ^ (s) : Int() ]] := true.
  	GetType [[ Boolean() ^ (s) : Bool() ]] := true.

  	[[ Identifier(id) ^ (s) : ty]] :=
	  	Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : ty.
  
  	[[ Const(v) ^ (s) : ty]] :=
    	[[ v ^ (s) : ty]].
  
  	[[ Integer(x) ^ (s) : Int()]] :=
  		true.
   
  	[[ Bool(x) ^ (s) : Bool()]] :=
   		true.
   
	[[ BinaryOperation(PlusOp(), a,b) ^ (s) : Int()  ]] := [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MinOp() , a,b) ^ (s) : Int()  ]] := [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MultOp(), a,b) ^ (s) : Int()  ]] := [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(AndOp(),  a,b) ^ (s) : Bool() ]] := [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(OrOp(),   a,b) ^ (s) : Bool() ]] := [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(ConcatOp(), a,b) ^ (s) : ty ]] := [[ a ^ (s) : c ]], [[ b ^ (s) : c ]].          // TODO
	
	[[ Print(x) ^ (s) : Unit() ]] :=
		[[ x ^ (s) : type ]].

	// Application type

  	[[ Application(e1, e2) ^ (s) : ty ]] := 
  		ty is simplifyApplicationType of (otherArgTys, funcRetTy),
	    [[ e1 ^ (s) : ([argTy | otherArgTys], funcRetTy) ]],
	    [[ e2 ^ (s) : argTy ]].
  
  
  	// Custom Map rule for unappended types
  	
  	Map2UT[[ xs ^ (s1,s2) : ty ]] := 
  		Map2UT(default)[[ xs ^ (s1,s2) : ty ]].
	
	Map2UT(X)[[ [x|xs] ^ (s1,s2) : ty ]] :=
		X[[ x ^ (s1,s2) : ty ]],
		Map2UT(X)[[ xs ^ (s1,s2) : ty ]].

	Map2UT(X)[[ [] ^ (s1,s2) : ty ]].