module static-semantics

imports

  	signatures/-

signature

  	constructors
    	Int : Type
    	Bool : Type
    	List : Type -> Type
    	Tuple : list(Tuple) -> Type
    	Unit : Type
    	Function : Type * Type -> Type
    	Forall : list(Var) * Term -> Term
    	TVar : String -> Term
    	
  	name resolution

    labels
      	P I

    order
      	D < I,
      	D < P,
      	I < P

    well-formedness
	  	(P* . I*)
	  
rules

  	init ^ (s) := new s.

	// Program Rules

  	[[ Program(expBlock, main) ^ (s) ]] :=
		new mainscope,
		new mainscopeinside,
		mainscopeinside -P-> mainscope,
  		ProgramExp [[ expBlock ^ (s, mainscope) : ty]],
  		[[ main ^ (mainscope,  mainscopeinside) : ty2]],
  		true.

  	ProgramExp[[ Some(block @ ExprBlock(_, _)) ^ (s, mainscope) : ty ]] :=
  		ProgramExp[[ block ^ (s, mainscope) : ty]].
  	
  	ProgramExp[[ None() ^ (s, mainscope) : ty ]] :=
    	mainscope -P-> s,
    	true.
	
  	ProgramExp[[ ExprBlock(LetExp(x), next) ^ (s, mainscope) : ty ]] := 
  		new s',
  		s' -P-> s,
		[[ x ^ (s, s') : ty1]],
		ProgramExp[[ next ^ (s', mainscope) : ty2 ]].
	
  	ProgramExp[[ ExprBlock(exp, next) ^ (s, mainscope) : ty ]] := 
		[[ exp ^ (s) : ty1 ]],
		ProgramExp[[ next ^ (s, mainscope) : ty2 ]].
	
	// Expression Block Rules
	
  	[[ ExprBlock(exp, None()) ^ (s) : ty]] := 
		[[ exp ^ (s) : ty ]].
	
  	[[ ExprBlock(exp, Some(next)) ^ (s) : ty]] := 
		[[ exp ^ (s) : ty1 ]],
		[[ next ^ (s) : ty ]].

	// Let Rules

  	[[ Let(id, args, retId, body) ^ (s, s') : argCurried2 ]] := 
		GetSpecifiedRetTy [[ retId ^ (s') : retTyp ]],	  // Constraint of the specified type
		MapCurry [[ args ^ (s_body, retTyp) : argCurried ]],
//		argCurried == Function(Int(),Int()),
		Const{id} <- s',
		Const{id} : argCurried2,
		argCurried2 genOf(vars) argCurried,
		new s_body,  
		s_body -P-> s,
	    [[ body ^ (s_body) : retTyp]].					  // Constraint of the infered type

	
	   
  	[[ LetRec(id, args, retTy, body) ^ (s, s') : (argTys, retTyp) ]] := 
//		Const{id} <- s,
//		Const{id} : (argTys, retTyp),
//		new s_body, 
//		s_body -P-> s,
//		Map1T(CheckParam) [[ args ^ (s_body) : argTys ]], // constraint of the arg types
//		GetSpecifiedRetTy [[ retTy ^ (s) : retTyp ]],	  // Constraint of the specified type
//	    [[ body ^ (s_body) : retTyp]].					  // Constraint of the infered type
	true.
    
  	[[ LetConst(id, retTy, body) ^ (s, s') : ty ]] := 
		Const{id} <- s',
		Const{id} : ty,
		new s_body, 
		s_body -P-> s,
		GetSpecifiedRetTy [[ retTy ^ (s) : ty ]],	  // Constraint of the specified type
	    [[ body ^ (s_body) : ty]].					  // Constraint of the infered type
    
    // Match Rules
    
    [[ Match(id, rules) ^ (s) : ty ]] :=
    	[[ id ^ (s) : idType ]],
    	Map2UT [[ rules ^ (s, idType) : ty ]].
    	
    [[ Rule(pattern, body) ^ (s, idType) : ty ]] :=
    	[[ pattern ^ (s) : idType ]],
    	[[ body ^ (s) : ty ]].
    	
    // Pattern Rules
    
    [[ Wildcard() ^ (s) : ty ]].
    
    [[ PatternOr(p1, p2) ^ (s) : ty ]] :=
    	[[ p1 ^ (s) : ty ]],
    	[[ p2 ^ (s) : ty ]].
    	
    [[ PatternList(p) ^ (s) : List(ty) ]] :=
    	Map1UT [[ p ^ (s) : ty ]].
    	
    [[ PatternConcat(p, plist) ^ (s) : List(ty) ]] :=
    	[[ p1 ^ (s) : ty ]],
    	[[ p2 ^ (s) : ty ]].
    	
	[[ PatternTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T [[ plist ^ (s) : ty]].
		
	// Type parameters
    
    [[ TypeDefinition(id, def) ^ (s) : ty ]] :=
		[[ def ^ (s) : ty ]],
		Type{id} <- s,
		Type{id} : ty.
    	
    [[ SingleType(t) ^ (s) : ty ]] :=
		[[ t ^ (s) : ty ]].
    	
    [[ IntegerType() ^ (s) : Int() ]].
    [[ BooleanType() ^ (s) : Bool() ]].
    [[ ListType(t) ^ (s) : List(ty) ]] :=
    	[[ t ^ (s) : ty ]].
        	
	[[ TypeTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T [[ plist ^ (s) : ty]].
    
  
  	// Function return types
   
	GetSpecifiedRetTy [[ None() ^ (s) : ty ]] := true.		 	// No return type specified; no additional constraint
	GetSpecifiedRetTy [[ Some(ReturnType(x)) ^ (s) : ty ]] :=  	// Additional constraint: the function should return the specified type
  		[[ x ^ (s) : ty ]].

	// Expressions and Values
	
  	[[ Identifier(id) ^ (s) : ty]] :=
	  	Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : ty.
  
  	[[ ArgIdentifier(id) ^ (s) : ty ]] := 
	    Const{id} <- s,
	    Const{id} : ty.
  	[[ TypedArgIdentifier(id, typ) ^ (s) : ty ]] := 
  		[[ typ ^ (s) : ty ]],
	  	Const{id} <- s,
	  	Const{id} : ty.
  		
  	[[ Const(v) ^ (s) : ty]] :=
    	[[ v ^ (s) : ty]].
  
  	[[ Integer(x) ^ (s) : Int()]].
   	[[ Bool(x) ^ (s) : Bool() ]].
   
	[[ BinaryOperation(PlusOp(), 	a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MinOp() , 	a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MultOp(), 	a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(AndOp(),  	a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(OrOp(),   	a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(ConcatOp(), 	a,b) ^ (s) : List(ty) ]] 	:= [[ a ^ (s) : ty ]], 	   [[ b ^ (s) : List(ty) ]].
	
	[[ Print(x) ^ (s) : Unit() ]] :=
		[[ x ^ (s) : type ]].
		
	[[ List(x) ^ (s) : List(ty) ]] :=
		Map1UT [[ x ^ (s) : ty ]].
        	
	[[ ExpTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T [[ plist ^ (s) : ty]].

	// Application type

	[[ Application(x@Identifier(_), e2) ^ (s) : funcRetTy ]] := 
	    [[ x ^ (s) : ty ]],
	    ty2 instOf ty,
	    ty2 == Function(argTy, funcRetTy),
	    [[ e2 ^ (s) : argTy ]].
  
  	[[ Application(e1, e2) ^ (s) : funcRetTy ]] := 
	    [[ e1 ^ (s) : Function(argTy, funcRetTy) ]],
	    [[ e2 ^ (s) : argTy ]].
  
  	// Custom Map rules for unappended types
  	
  	Map1UT[[ xs ^ (s1) : ty ]] := 
  		Map1UT(default)[[ xs ^ (s1) : ty ]].
	
	Map1UT(X)[[ [x|xs] ^ (s1) : ty ]] :=
		X[[ x ^ (s1) : ty ]],
		Map1UT(X)[[ xs ^ (s1) : ty ]].

	Map1UT(X)[[ [] ^ (s1) : ty ]].
  	
  	Map2UT[[ xs ^ (s1,s2) : ty ]] := 
  		Map2UT(default)[[ xs ^ (s1,s2) : ty ]].
	
	Map2UT(X)[[ [x|xs] ^ (s1,s2) : ty ]] :=
		X[[ x ^ (s1,s2) : ty ]],
		Map2UT(X)[[ xs ^ (s1,s2) : ty ]].

	Map2UT(X)[[ [] ^ (s1,s2) : ty ]].
	
	MapCurry [[ [x|[]] ^ (s, retTy) : Function(argType, retTy) ]] :=
		[[ x ^ (s) : argType ]].
		
	MapCurry [[ [x|xs] ^ (s, retTy) : Function(argType, ty) ]] :=
		[[ x ^ (s) : argType ]],
		MapCurry [[ xs ^ (s, retTy) : ty ]].
	