module static-semantics

imports

  	signatures/-

signature

  	constructors
    	Int : Type
    	Bool : Type
    	List : Type -> Type
    	Tuple : list(Tuple) -> Type
    	Unit : Type
    	Function : Type * Type -> Type
    	Forall : list(Var) * Term -> Term
    	TVar : String -> Term
    	Origin : String
    	Union : list(Type) -> Type 
    	
  	name resolution

    labels
      	P I

    order
      	D < I,
      	D < P,
      	I < P

    well-formedness
	  	(P* . I*)
	  
rules

  	init ^ (s) := new s.

	// Program Rules

  	[[ Program(expBlock, main) ^ (s) ]] :=
		new mainscope,
  		ProgramExp [[ expBlock ^ (s, mainscope) : ty]],
  		[[ main ^ (mainscope) : ty2]],
  		true.

  	ProgramExp[[ Some(block @ ExprBlock(_, _)) ^ (s, mainscope) : ty ]] :=
  		OuterExprBlock[[ block ^ (s, mainscope) : ty]].
  	
  	ProgramExp[[ None() ^ (s, mainscope) : ty ]] :=
    	mainscope -P-> s,
    	true.
	
	// Expression Block Rules
	
  	OuterExprBlock[[ ExprBlock(exp, None()) ^ (s, mainscope) : ty]] := 
		[[ exp ^ (s) : ty ]],
		mainscope -P-> s.
	
  	OuterExprBlock[[ ExprBlock(exp, Some(next)) ^ (s, mainscope) : ty]] := 
		[[ exp ^ (s) : ty1 ]],
		new s',
		s' -P-> s,
		OuterExprBlock[[ next ^ (s', mainscope) : ty ]].
	
  	InnerExprBlock[[ ExprBlock(exp, None()) ^ (s) : ty]] := 
		[[ exp ^ (s) : ty ]].
	
  	InnerExprBlock[[ ExprBlock(exp, Some(next)) ^ (s) : ty]] := 
		[[ exp ^ (s) : ty1 ]],
		new s',
		s' -P-> s,
		InnerExprBlock[[ next ^ (s') : ty ]].

	// Let Rules

  	[[ Let(id, args, retId, body) ^ (s) : argCurried2 ]] := 
		GetSpecifiedRetTy [[ retId ^ (s) : retTyp ]],
		new s_body, 
		s_body -P-> s,
	    InnerExprBlock[[ body ^ (s_body) : retTyp]],
		MapCurry [[ args ^ (s_body, retTyp) : argCurried ]],
		argCurried2 genOf(vars) argCurried,
		Const{id} <- s,
		Const{id} : argCurried2,
		Const{id}.origin := "let-binding".
	   
  	[[ LetRec(id, args, retTy, body) ^ (s) : argCurried2 ]] := 
		GetSpecifiedRetTy [[ retId ^ (s) : retTyp ]],
		MapCurry [[ args ^ (s_body, retTyp) : argCurried ]],
		argCurried2 genOf(vars) argCurried,
		new s_body, 
		s_body -P-> s,
		Const{id} <- s,
		Const{id} <- s_body,
		Const{id} : argCurried2,
		Const{id}.origin := "let-binding",
	    InnerExprBlock[[ body ^ (s_body) : retTyp]].
    
  	[[ LetConst(id, retTy, body) ^ (s) : ty ]] := 
		GetSpecifiedRetTy [[ retTy ^ (s) : ty ]],
		Const{id} <- s,
		Const{id} : ty,
		new s_body, 
		s_body -P-> s,
	    InnerExprBlock[[ body ^ (s_body) : ty]].
    
    // Match Rules
    
    [[ Match(id, rules) ^ (s) : ty ]] :=
    	[[ id ^ (s) : idType ]],
    	Map2UT [[ rules ^ (s, idType) : ty ]].
    	
    [[ Rule(pattern, body) ^ (s, idType) : ty ]] :=
    	[[ pattern ^ (s) : idType ]],
    	[[ body ^ (s) : ty ]].
    	
    // Pattern Rules
    
    [[ Wildcard() ^ (s) : ty ]].
    
    [[ PatternOr(p1, p2) ^ (s) : ty ]] :=
    	[[ p1 ^ (s) : ty ]],
    	[[ p2 ^ (s) : ty ]].
    	
    [[ PatternList(p) ^ (s) : List(ty) ]] :=
    	Map1UT [[ p ^ (s) : ty ]].
    	
    [[ PatternConcat(p, plist) ^ (s) : List(ty) ]] :=
    	[[ p1 ^ (s) : ty ]],
    	[[ p2 ^ (s) : ty ]].
    	
	[[ PatternTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T [[ plist ^ (s) : ty]].
		
	// Type parameters
    
    [[ TypeDefinition(id, def) ^ (s) : ty ]] :=
		[[ def ^ (s) : ty ]],
		Const{id} <- s,
		Const{id} : ty.
    	
    [[ SingleType(t) ^ (s) : ty ]] :=
		[[ t ^ (s) : ty ]].
    	
    [[ IntegerType() ^ (s) : Int() ]].
    [[ BooleanType() ^ (s) : Bool() ]].
    [[ ListType(t) ^ (s) : List(ty) ]] :=
    	[[ t ^ (s) : ty ]].
        	
	[[ TypeTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T [[ plist ^ (s) : ty]].
    
    // Union types
    
    [[ TypeEscaped(a, alist) ^ (s) : Union([ty|tylist]) ]] :=
    	TypeEscaped [[ a ^ (s) : ty ]],
    	Map1T(TypeEscaped) [[ alist ^ (s) : tylist ]].
    	
    TypeEscaped [[ TypedID(id, type) ^ (s) : ty ]] :=
    	[[ type ^ (s) : ty ]],
		Const{id} <- s,
		Const{id} : Function(ty, ty).
		
    TypeEscaped [[ TypeConstIdentifier(id) ^ (s) : ty ]] :=
		Const{id} <- s,
		Const{id} : ty.
		
  	// Function return types
   
	GetSpecifiedRetTy [[ None() ^ (s) : ty ]] := true.		 	// No return type specified; no additional constraint
	GetSpecifiedRetTy [[ Some(ReturnType(x)) ^ (s) : ty ]] :=  	// Additional constraint: the function should return the specified type
  		[[ x ^ (s) : ty ]].

	// Expressions and Values
	
  	[[ Identifier(id) ^ (s) : ty]] :=
	  	Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : ty.
	
  	[[ TypeConstIdentifier(id) ^ (s) : ty]] :=
	  	Const{id} -> s, 
	  	Const{id} |-> d,
	  	d : ty.
  
  	[[ ArgIdentifier(id) ^ (s) : ty ]] := 
	    Const{id} <- s,
	    Const{id} : ty,
	    Const{id}.origin := "param".
	    
  	[[ TypedArgIdentifier(id, typ) ^ (s) : ty ]] := 
  		[[ typ ^ (s) : ty ]],
	  	Const{id} <- s,
	  	Const{id} : ty,
	  	Const{id}.origin := "param".
  		
  	[[ Const(v) ^ (s) : ty]] :=
    	[[ v ^ (s) : ty]].
  
  	[[ Integer(x) ^ (s) : Int()]].
   	[[ Bool(x) ^ (s) : Bool() ]].
   
	[[ BinaryOperation(PlusOp(), 		a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MinOp() , 		a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(MultOp(), 		a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(EqualOp(), 		a,b) ^ (s) : ty  ]] 		:= [[ a ^ (s) : ty  ]],    [[ b ^ (s) : ty  ]].
	[[ BinaryOperation(SmallerOp(), 	a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(SmallerEqualOp(),a,b) ^ (s) : Int()  ]] 		:= [[ a ^ (s) : Int()  ]], [[ b ^ (s) : Int()  ]].
	[[ BinaryOperation(AndOp(),  		a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(OrOp(),   		a,b) ^ (s) : Bool() ]] 		:= [[ a ^ (s) : Bool() ]], [[ b ^ (s) : Bool() ]].
	[[ BinaryOperation(ConcatOp(), 		a,b) ^ (s) : List(ty) ]] 	:= [[ a ^ (s) : ty ]], 	   [[ b ^ (s) : List(ty) ]].
	
	[[ Print(x) ^ (s) : Unit() ]] :=
		[[ x ^ (s) : type ]].
		
	[[ List(x) ^ (s) : List(ty) ]] :=
		Map1UT [[ x ^ (s) : ty ]].
        	
	[[ ExpTuple(plist) ^ (s) : Tuple(ty) ]] :=
		Map1T [[ plist ^ (s) : ty]].

	// Application type

	[[ Application(x@Identifier(_), e2) ^ (s) : funcRetTy ]] := 
	    [[ x ^ (s) : ty ]],
	    ty2 instOf ty,
	    ty2 == Function(argTy, funcRetTy),
	    [[ e2 ^ (s) : argTy ]].
  
  	[[ Application(e1, e2) ^ (s) : funcRetTy ]] := 
	    [[ e1 ^ (s) : Function(argTy, funcRetTy) ]],
	    [[ e2 ^ (s) : argTy ]].
  
  	// Custom Map rules for unappended types
  	
  	Map1UT[[ xs ^ (s1) : ty ]] := 
  		Map1UT(default)[[ xs ^ (s1) : ty ]].
	
	Map1UT(X)[[ [x|xs] ^ (s1) : ty ]] :=
		X[[ x ^ (s1) : ty ]],
		Map1UT(X)[[ xs ^ (s1) : ty ]].

	Map1UT(X)[[ [] ^ (s1) : ty ]].
  	
  	Map2UT[[ xs ^ (s1,s2) : ty ]] := 
  		Map2UT(default)[[ xs ^ (s1,s2) : ty ]].
	
	Map2UT(X)[[ [x|xs] ^ (s1,s2) : ty ]] :=
		X[[ x ^ (s1,s2) : ty ]],
		Map2UT(X)[[ xs ^ (s1,s2) : ty ]].

	Map2UT(X)[[ [] ^ (s1,s2) : ty ]].
	
	MapCurry [[ [x|[]] ^ (s, retTy) : Function(argType, retTy) ]] :=
		[[ x ^ (s) : argType ]].
		
	MapCurry [[ [x|xs] ^ (s, retTy) : Function(argType, ty) ]] :=
		[[ x ^ (s) : argType ]],
		MapCurry [[ xs ^ (s, retTy) : ty ]].
	