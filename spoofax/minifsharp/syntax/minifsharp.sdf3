module minifsharp

imports
  
	Common

lexical syntax

	Identifier					= [a-zA-Z] [a-zA-Z0-9]* 
	TypeConstIdentifier			= [A-Z] [a-zA-Z0-9]* 
	Integer						= [0-9]+

	Identifier.Let    			= "let"   {reject}
	Identifier.Rec    			= "rec"   {reject}
	Identifier.Match  			= "match" {reject}
	Identifier.With   			= "with"  {reject}
	Identifier.Printf 			= "printf"{reject}
	Identifier.Type   			= "type"  {reject}
	Identifier.True 			= "true"  {reject}
	Identifier.False  			= "false" {reject}
	Identifier.Int    			= "int"   {reject}
	Identifier.Bool   			= "bool"  {reject}
	Identifier.List   			= "list"  {reject}

	TypeConstIdentifier.Let    	= "let"   {reject}
	TypeConstIdentifier.Rec    	= "rec"   {reject}
	TypeConstIdentifier.Match  	= "match" {reject}
	TypeConstIdentifier.With   	= "with"  {reject}
	TypeConstIdentifier.Printf 	= "printf"{reject}
	TypeConstIdentifier.Type   	= "type"  {reject}
	TypeConstIdentifier.True 	= "true"  {reject}
	TypeConstIdentifier.False  	= "false" {reject}
	TypeConstIdentifier.Int    	= "int"   {reject}
	TypeConstIdentifier.Bool   	= "bool"  {reject}
	TypeConstIdentifier.List   	= "list"  {reject}
	
lexical restrictions

	Identifier          		-/- [a-zA-Z0-9]
	TypeConstIdentifier 		-/- [a-zA-Z0-9]
	Integer             		-/- [a-zA-Z0-9]

lexical syntax start-symbols

	Identifier
	TypeConstIdentifier
	Integer

context-free start-symbols

	Program
	Expression

context-free syntax
  
	Program.Program				= <<ExprBlock?> [\<EntryPoint\>] <Let>>
	
	Expression.LetExp			= <<Let>>
	Expression.Match			= <match <Expression> with <Rules>>
	Expression.Print			= <printf <Expression>>
	Expression.TypeDefinition	= <type <Identifier> = <TypeDefinition>>							{layout(and(and(	gt(col(first(2)),col(first(1))), 
																	 													gt(col(first(3)),col(first(1))))),
																	 													gt(col(first(4)),col(first(1))))}
	Expression.Const			= <<Const>>
	Expression.Identifier		= <<Identifier>>
	Expression.Application		= <<Expression> <Expression>> 										{layout(			gt(col(first(2)),col(first(1))))}	// second Expression must be on a righter column than first Expression
	Expression.SugaredTupleExp	= <<Expression> , <{Expression ","}+>>
	Expression.List				= <[<{Expression ";"}*>]>
	Expression.Plus				= <<Expression> + <Expression>>										{layout(and(		ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("2")))))} // + is allowed to be two columns to the left
	Expression.Min				= <<Expression> - <Expression>> 									{layout(and(		ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("2")))))} // - is allowed to be two columns to the left
	Expression.Mult				= <<Expression> * <Expression>>										{layout(and(		ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("2")))))} // * is allowed to be two columns to the left
	Expression.Concat			= <<Expression> :: <Expression>>									{layout(and(		ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // :: is allowed to be two columns to the left
	Expression.And				= <<Expression> && <Expression>>									{layout(and(		ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // && is allowed to be two columns to the left
	Expression.Or				= <<Expression> || <Expression>>									{layout(and(		ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // || is allowed to be two columns to the left
	Expression.Negative			= <-<Expression>>
	Expression.Not				= <! <Expression>>
	Expression					= <(<Expression>)>													{bracket}
	
	Let.Let						= <let <Identifier> <Argument+> <ReturnType?> = <ExprBlock>> 		{layout(and(		gt(col(first(5)),col(first(1))), 	// "=" must be on a a righter column than let
																														gt(col(first(6)),col(first(1)))))}	// ExprBlock must be on a a righter column than let
	Let.LetRec					= <let rec <Identifier> <Argument*> <ReturnType?> = <ExprBlock>> 	{layout(and(		gt(col(first(6)),col(first(1))), 	// "=" must be on a righter column than let
																														gt(col(first(7)),col(first(1)))))}	// ExprBlock must be on a righter column than let
	Let.LetConst				= <let <Identifier> <ReturnType?> = <ExprBlock>> 		            {layout(and(		gt(col(first(4)),col(first(1))), 	// "=" must be on a a righter column than let
																														gt(col(first(5)),col(first(1)))))}	// ExprBlock must be on a a righter column than let
	
	
	ExprBlock.ExprBlock   		= <<ExprNewline> <ExprBlock?>> 										{layout(eq(			col(first(1)),col(first(2))))}		// all Expressions must be on the same column
	
	Const.Integer				= <<Integer>>
	Const.Bool					= <<Boolean>>
	
	Boolean.True				= <true>
	Boolean.False				= <false>
	
	ReturnType.ReturnType		= <: <Type>>
	
	Argument.Identifier			= <<Identifier>>
	Argument.TypedIdentifier	= <( <Identifier> : <Type> )>
	
	Rules.RulesEscaped			= <<RuleFirst> <Rule*>>												{layout(			ge(col(first(2)),col(first(1))))}
	Rules.Rules					= <<Rule> <Rule*>>													{layout(			ge(col(first(2)),col(first(1))))}
	
	RuleFirst.RuleFirst			= <<Pattern> -\> <Expression>> 										{layout(and(		ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1)))))}
	Rule.Rule					= <| <Pattern> -\> <Expression>> 									{layout(and(and(	ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1))))),
																	 													ge(col(first(4)),col(first(1))))}
	
	// TypeDefinition.TypeEscaped	= <<Type> | <{Type "|"}+>>
	// TypeDefinition.Type			= <| <Type> | <{Type "|"}+>>
	TypeDefinition.SingleType	= <<Type>>
	
	Type.Integer				= <int>
	Type.Boolean				= <bool>
	Type.Identifier				= <<Identifier>>
	Type.TypeIdentifier			= <<TypeConstIdentifier>>
	Type.ListType				= <<Type> list>														{layout(			gt(col(first(2)),col(first(1))))}
	Type.TypedIdentifier		= <<TypeConstIdentifier> of <Type>>									{layout(and(		gt(col(first(2)),col(first(1))), 
																	 													gt(col(first(3)),col(first(1)))))}
	Type.SugaredTupleType 		= <<Type> * <{Type "*"}+>>											{layout(and(		gt(col(first(2)),col(first(1))), 
																	 													gt(col(first(3)),col(first(1)))))}
	Type						= <(<Type>)>														{bracket}
	
	Pattern.Wildcard			= <_>
	Pattern.Concat				= <<Pattern> :: <Pattern>>											{layout(and(		ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1)))))}
	Pattern.List				= <<ListPattern>>
	Pattern.Or					= <<Pattern> | <Pattern>>											{layout(and(		ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1)))))}
	Pattern.Tuple				= <<Pattern> , <{Pattern "*"}+>>									{layout(and(		ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1)))))}
	// Pattern.TypeConst			= <<TypeConstIdentifier> <Const?>>
	// Pattern.TypeConstIdentifier	= <<TypeConstIdentifier> <Identifier?>>
	Pattern.Const				= <<Const>>
	Pattern.Identifier			= <<Identifier>>
	Pattern						= <(<Pattern>)>														{bracket}
	
	ListPattern.ListPattern		= <[<{Pattern ";"}*>]>
	
syntax
		
	ExprNewline-CF = Expression-CF LAYOUT?-CF {enforce-newline}
	
context-free priorities

  { left:
	Expression.Application
  } > { left:
    Expression.Plus
	Expression.Min
	Expression.Mult
	Expression.Concat
	Expression.And
	Expression.Or
  } > { left:
	Expression.Negative
	Expression.Not
  } > { left: 
    Expression.LetExp
  } > { left:
	Expression.Match
  }
	
	
