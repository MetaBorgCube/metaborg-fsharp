module minifsharp

imports
  
	Common

lexical syntax

	Identifier					= [a-zA-Z] [a-zA-Z0-9]* 
	TypeConstIdentifier			= [A-Z] [a-zA-Z0-9]* 
	Integer						= [0-9]+

	Identifier.Let    			= "let"   {reject}
	Identifier.Rec    			= "rec"   {reject}
	Identifier.Match  			= "match" {reject}
	Identifier.With   			= "with"  {reject}
	Identifier.Printf 			= "printf"{reject}
	Identifier.Type   			= "type"  {reject}
	Identifier.True 			= "true"  {reject}
	Identifier.False  			= "false" {reject}
	Identifier.Int    			= "int"   {reject}
	Identifier.Bool   			= "bool"  {reject}
	Identifier.List   			= "list"  {reject}
	Identifier.EntryPoint   	= "[<EntryPoint>]"  {reject}
	
lexical restrictions

	Identifier          		-/- [a-zA-Z0-9]
	TypeConstIdentifier 		-/- [a-zA-Z0-9]
	Integer             		-/- [0-9]

lexical syntax start-symbols

	Identifier
	TypeConstIdentifier
	Integer

context-free start-symbols

	Program

context-free syntax
  
	Program.Program				= <<ExprBlock?> [\<EntryPoint\>] <Let>>
	
	Expression.Let				= <<Let>>
	Expression.Match			= <match <Expression> with <Rules>>
	Expression.Print			= <printf <Expression>>
	Expression.TypeDefinition	= <type <Identifier> = <TypeDefinition>>
	Expression.Const			= <<Const>>
	Expression.Identifier		= <<Identifier>>
	Expression.Application		= <<Expression> <Expression>> 										{layout(			gt(col(first(2)),col(first(1))))}	// second Expression must be on a righter column than first Expression
	Expression.Tuple			= <<Expression> , <{Expression ","}+>>
	Expression.List				= <[<{Expression ";"}*>]>
	Expression.Plus				= <<Expression> + <Expression>>
	Expression.Min				= <<Expression> - <Expression>>
	Expression.Mult				= <<Expression> * <Expression>>
	Expression.Concat			= <<Expression> :: <Expression>>
	Expression.And				= <<Expression> && <Expression>>
	Expression.Or				= <<Expression> || <Expression>>
	Expression.Negative			= <-<Expression>>
	Expression.Not				= <! <Expression>>
	Expression					= <(<Expression>)>													{bracket}
	
	Let.Let						= <let <Identifier> <Arguments?> <ReturnType?> = <ExprBlock>> 		{layout(and(		gt(col(first(5)),col(first(1))), 	// "=" must be on a a righter column than let
																														gt(col(first(6)),col(first(1)))))}	// ExprBlock must be on a a righter column than let
	Let.LetRec					= <let rec <Identifier> <Arguments?> <ReturnType?> = <ExprBlock>> 	{layout(and(		gt(col(first(6)),col(first(1))), 	// "=" must be on a righter column than let
																														gt(col(first(7)),col(first(1)))))}	// ExprBlock must be on a righter column than let
	
	ExprBlock.ExprBlock   		= <<ExprNewline> <ExprNewline*>> 									{layout(eq(			col(first(1)),col(first(2))))}		// all Expressions must be on the same column
	
	Const.Integer				= <<Integer>>
	Const.Bool					= <<Boolean>>
	
	Boolean.True				= <true>
	Boolean.False				= <false>
	
	ReturnType.ReturnType		= <: <Type>>
	
	Arguments.Arguments			= <<Argument+>>
	Argument.Identifier			= <<Identifier>>
	Argument.TypedIdentifier	= <( <Identifier> : <Type> )>
	
	Rules.RulesEscaped			= <<RuleFirst> <Rule*>>												{layout(			ge(col(first(2)),col(first(1))))}
	Rules.Rules					= <<Rule> <Rule*>>													{layout(			ge(col(first(2)),col(first(1))))}
	
	RuleFirst.RuleFirst			= <<Pattern> -\> <Expression>> 										{layout(and(		ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1)))))}
	Rule.Rule					= <| <Pattern> -\> <Expression>> 									{layout(and(and(	ge(col(first(2)),col(first(1))), 
																	 													ge(col(first(3)),col(first(1))))),
																	 													ge(col(first(4)),col(first(1))))}
	
	TypeDefinition.TypeEscaped	= <<{Type "|"}*>>
	TypeDefinition.Type			= <| <{Type "|"}*>>
	
	Type.Integer				= <int>
	Type.Boolean				= <bool>
	Type.Identifier				= <<Identifier>>
	Type.TypeIdentifier			= <<TypeConstIdentifier>>
	Type.List					= <<Type> list>
	Type.TypedIdentifier		= <<Identifier> of <Type>>
	Type.Tuple					= <<Type> * <{Type "*"}+>>
	Type						= <(<Type>)>														{bracket}
	
	Pattern.Wildcard			= <_>
	Pattern.Concat				= <<Pattern> :: <Pattern>>
	Pattern.List				= <<ListPattern>>
	Pattern.Or					= <<Pattern> $ <Pattern>>
	Pattern.Tuple				= <<Pattern> , <Pattern>>
	Pattern.TypeConst			= <<TypeConstIdentifier> <Const?>>
	Pattern.TypeConstIdentifier	= <<TypeConstIdentifier> <Identifier?>>
	Pattern.Const				= <<Const>>
	Pattern.Identifier			= <<Identifier>>
	Pattern						= <(<Pattern>)>														{bracket}
	
	ListPattern.ListPattern		= <[<{Pattern ";"}*>]>
	
	syntax
		
	ExprNewline-CF = Expression-CF LAYOUT?-CF {enforce-newline}
	
context-free priorities
  { left:
    Expression.Plus
	Expression.Min
	Expression.Mult
	Expression.Concat
	Expression.And
	Expression.Or
  } > { left:
	Expression.Negative
	Expression.Not
  }
	
	
