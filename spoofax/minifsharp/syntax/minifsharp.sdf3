module minifsharp

imports

	Common

lexical syntax

	Identifier					= [a-zA-Z] [a-zA-Z0-9]*
	TypeConstIdentifier			= [A-Z] [a-zA-Z0-9]*
	Integer						= [0-9]+

	Identifier.Let    			= "let"   {reject}
	Identifier.Rec    			= "rec"   {reject}
	Identifier.Match  			= "match" {reject}
	Identifier.With   			= "with"  {reject}
	Identifier.Printf 			= "printf"{reject}
	Identifier.Type   			= "type"  {reject}
	Identifier.True 			= "true"  {reject}
	Identifier.False  			= "false" {reject}
	Identifier.Int    			= "int"   {reject}
	Identifier.Bool   			= "bool"  {reject}
	Identifier.List   			= "list"  {reject}
	Identifier.If   			= "if"    {reject}
	Identifier.Else   			= "else"  {reject}

	TypeConstIdentifier.Let    	= "let"   {reject}
	TypeConstIdentifier.Rec    	= "rec"   {reject}
	TypeConstIdentifier.Match  	= "match" {reject}
	TypeConstIdentifier.With   	= "with"  {reject}
	TypeConstIdentifier.Printf 	= "printf"{reject}
	TypeConstIdentifier.Type   	= "type"  {reject}
	TypeConstIdentifier.True 	= "true"  {reject}
	TypeConstIdentifier.False  	= "false" {reject}
	TypeConstIdentifier.Int    	= "int"   {reject}
	TypeConstIdentifier.Bool   	= "bool"  {reject}
	TypeConstIdentifier.List   	= "list"  {reject}
	TypeConstIdentifier.If   	= "if"    {reject}
	TypeConstIdentifier.Else   	= "else"  {reject}

lexical restrictions

	Identifier          		-/- [a-zA-Z0-9]
	TypeConstIdentifier 		-/- [a-zA-Z0-9]
	Integer             		-/- [a-zA-Z0-9]

lexical syntax start-symbols

	Identifier
	TypeConstIdentifier
	Integer

context-free start-symbols

	Program
	OuterExp

context-free syntax

	// Program

	Program.Program				= <<ExprBlock?> [\<EntryPoint\>] <Let>>

	// Expressions


	OuterExp                   	= Expression
	OuterExp.OuterExpTuple  	= RawExpTuple

	RawExpTuple.RawExpTuple 	= <<Expression> , <{Expression ","}+>>
	Expression.NestedExpTuple	= <(<RawExpTuple>)>			

	Expression.LetExp			= <<Let>>
	Expression.Match			= <match <Expression> with <Rules>>
	Expression.Print			= <printf <Expression>>
	Expression.TypeDefinition	= <type <Identifier> = <TypeDefinition>>							{layout(and(and(	gt(col(first(2)),col(first(1))),
																	 													gt(col(first(3)),col(first(1))))),
																	 													gt(col(first(4)),col(first(1))))}
	
	Expression.Const			= <<Const>>
	Expression.Identifier		= <<Identifier>>
	Expression.Application		= <<Expression> <Expression>> 										{layout(			gt(col(first(2)),col(first(1))))}	// second Expression must be on a righter column than first Expression
	Expression.List				= <[<{Expression ";"}*>]>
	Expression.Plus				= <<Expression> + <Expression>>										{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("2")))))} // op is allowed to be two columns to the left
	Expression.Min				= <<Expression> - <Expression>> 									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("2")))))} // op is allowed to be two columns to the left
	Expression.Mult				= <<Expression> * <Expression>>										{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("2")))))} // op is allowed to be two columns to the left
	Expression.Concat			= <<Expression> :: <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.And				= <<Expression> && <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.Or				= <<Expression> || <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.Equal			= <<Expression> == <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.NotEqual			= <<Expression> != <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.Smaller			= <<Expression> \< <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.Greater			= <<Expression> \> <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.SmallerEqual		= <<Expression> \<= <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.GreaterEqual		= <<Expression> \>= <Expression>>									{left,layout(and(	ge(col(first(3)),col(first(1))),				  // second expression should not be further to the left
																														ge(col(first(2)),sub(col(first(1)), num("3")))))} // op is allowed to be two columns to the left
	Expression.Negative			= <-<Expression>>
	Expression.Not				= <! <Expression>>
	Expression.If				= <<If>>
	Expression					= <(<Expression>)>													{bracket}
	
	If.If						= <if <Expression> then <OuterExp> <IfElse>>
	IfElse.IfElse				= <else if <Expression> then <OuterExp> <IfElse?>>
	IfElse.Else					= <else <OuterExp> <IfElse?>>

	Let.Let						= <let <Identifier> <Argument+> <ReturnType?> = <ExprBlock>> 		{layout(and(		gt(col(first(5)),col(first(1))), 	// "=" must be on a a righter column than let
																														gt(col(first(6)),col(first(1)))))}	// ExprBlock must be on a a righter column than let
	Let.LetRec					= <let rec <Identifier> <Argument*> <ReturnType?> = <ExprBlock>> 	{layout(and(		gt(col(first(6)),col(first(1))), 	// "=" must be on a righter column than let
																														gt(col(first(7)),col(first(1)))))}	// ExprBlock must be on a righter column than let
	Let.LetConst				= <let <Identifier> <ReturnType?> = <ExprBlock>> 		            {layout(and(		gt(col(first(4)),col(first(1))), 	// "=" must be on a a righter column than let
																														gt(col(first(5)),col(first(1)))))}	// ExprBlock must be on a a righter column than let


	ExprBlock.ExprBlock   		= <<ExprNewline> <ExprBlock?>> 										{layout(eq(			col(first(1)),col(first(2))))}		// all Expressions must be on the same column

	// Integers and Booleans

	Const.Integer				= <<Integer>>
	Const.Bool					= <<Boolean>>

	Boolean.True				= <true>
	Boolean.False				= <false>

	// Return types and Arguments

	ReturnType.ReturnType		= <: <OuterType>>

	Argument.ArgIdentifier		= <<Identifier>>
	Argument.TypedArgIdentifier	= <( <Identifier> : <OuterType> )>

	// Rules

	Rules.RulesEscaped			= <<RuleFirst> <Rule*>>												{layout(			ge(col(first(2)),col(first(1))))}
	Rules.Rules					= <<Rule> <Rule*>>													{layout(			ge(col(first(2)),col(first(1))))}

	RuleFirst.RuleFirst			= <<OuterPattern> -\> <Expression>> 								{layout(and(		ge(col(first(2)),col(first(1))),
																	 													ge(col(first(3)),col(first(1)))))}
	Rule.Rule					= <| <OuterPattern> -\> <Expression>> 								{layout(and(and(	ge(col(first(2)),col(first(1))),
																	 													ge(col(first(3)),col(first(1))))),
																	 													ge(col(first(4)),col(first(1))))}

	// Types
	
	TypeDefinition.TypeEscaped	= <<TypedID> | <{TypedID "|"}+>>
	TypeDefinition.Type			= <| <TypedID> | <{TypedID "|"}+>>
	TypeDefinition.SingleType	= <<OuterType>>

	OuterType                   = Type
	OuterType.OuterTypeTuple  	= RawTypeTuple

	RawTypeTuple.RawTypeTuple 	= <<Type> * <{Type "*"}+>>

	Type.IntegerType			= <int>
	Type.BooleanType			= <bool>
	Type.Identifier				= <<Identifier>>
	Type.ListType				= <<Type> list>														{layout(			gt(col(first(2)),col(first(1))))}
	Type.TypedID				= <<TypedID>>
	Type.TypeConstIdentifier	= <<TypeConstIdentifier>>
	TypedID.TypedID				= <<TypeConstIdentifier> of <Type>>									{layout(and(		gt(col(first(2)),col(first(1))),
																	 													gt(col(first(3)),col(first(1)))))}
	TypedID.TypeConstIdentifier	= <<TypeConstIdentifier>>
	Type						= <(<Type>)>														{bracket}
	Type.NestedTypeTuple		= <(<RawTypeTuple>)>

	// Patterns
	
	Pattern.TypeConst				= <<TypeConstIdentifier> <Const?>>
	Pattern.TypeConstIdentifier		= <<TypeConstIdentifier> <Identifier?>>

	OuterPattern                    = Pattern
	OuterPattern.OuterPatternTuple  = RawPatternTuple

	RawPatternTuple.RawPatternTuple = <<Pattern> , <{Pattern ","}+>> 								{layout(and(		ge(col(first(2)),col(first(1))),
																														ge(col(first(3)),col(first(1)))))}

	Pattern.Wildcard			    = <_>
	Pattern.PatternConcat			= <<Pattern> :: <Pattern>>										{layout(and(		ge(col(first(2)),col(first(1))),
																	 													ge(col(first(3)),col(first(1)))))}
	Pattern.PatternList				=  <[<{Pattern ";"}*>]>
	Pattern.PatternOr				= <<Pattern> | <Pattern>>										{layout(and(		ge(col(first(2)),col(first(1))),
																	 													ge(col(first(3)),col(first(1)))))}

	Pattern.Const					= <<Const>>
	Pattern.Identifier				= <<Identifier>>
	Pattern.NestedPatternTuple		= <(<RawPatternTuple>)>

syntax

	ExprNewline-CF = OuterExp-CF LAYOUT?-CF {enforce-newline}

context-free priorities

  	{ left:
		Expression.Application
  	} > { left:
	    Expression.Plus
		Expression.Min
		Expression.Mult
		Expression.Concat
		Expression.And
		Expression.Or
	} > { left:
		Expression.Negative
		Expression.Not
	} > { left:
	    Expression.LetExp
	} > { left:
		Expression.Match
	}
