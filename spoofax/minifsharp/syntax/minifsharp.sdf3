module minifsharp

imports
  
	Common

lexical syntax

	Identifier					= [a-zA-Z] [a-zA-Z0-9]* 
	TypeConstIdentifier			= [A-Z] [a-zA-Z0-9]* 
	Integer						= [0-9]+

	Identifier.Let    = "let"   {reject}
	Identifier.Rec    = "rec"   {reject}
	Identifier.Match  = "match" {reject}
	Identifier.With   = "with"  {reject}
	Identifier.Printf = "printf"{reject}
	Identifier.Type   = "type"  {reject}
	Identifier.True   = "true"  {reject}
	Identifier.False  = "false" {reject}
	Identifier.Int    = "int"   {reject}
	Identifier.Bool   = "bool"  {reject}
	Identifier.List   = "list"  {reject}
	
lexical restrictions

Identifier          -/- [a-zA-Z0-9]
TypeConstIdentifier -/- [a-zA-Z0-9]
Integer             -/- [0-9]

lexical syntax start-symbols

	Identifier
	TypeConstIdentifier
	Integer

context-free start-symbols

	Program

context-free syntax
  
	Program.Program				= <<Expression*> "[\<EntryPoint\>]" <Expression+>>
	
	Expression.Let				= <let <FunctionDefinition>>
	Expression.LetRec			= <let rec <FunctionDefinition>>
	Expression.Match			= <match <Expression> with <Rules>>
	Expression.Print			= <printf <Expression>>
	Expression.TypeDefinition	= <type <Identifier> = <TypeDefinition>>
	Expression.Const			= <<Const>>
	Expression.Identifier		= <<Identifier>>
	Expression.Encapsulation	= <(<Expression>)>
	Expression.Application		= <<Expression> <Expression>>
	Expression.BinaryOperation	= <<Expression> <BinaryOperand> <Expression>>
	Expression.UnaryOperation	= <<UnaryOperand> <Expression>>
	Expression.Tuple			= <{<Expression> ,}+>
	Expression.List				= <[<{Expression ";"}*>]>
	
	FunctionDefinition.Function	= <<Identifier> <Arguments> <ReturnType?> = <Expression>>

	Const.Integer				= <<Integer>>
	Const.Bool					= <<Boolean>>
	
	Boolean.True				= <true>
	Boolean.False				= <false>
	
	BinaryOperand.Plus			= <+>
	BinaryOperand.Min			= <->
	BinaryOperand.Mult			= <*>
	BinaryOperand.Concat		= <::>
	BinaryOperand.And			= <&&>
	BinaryOperand.Or			= <||>

	UnaryOperand.Min			= <->
	UnaryOperand.Negation		= <!>
	
	ReturnType					= <<Type>>
	
	Arguments.Arguments			= <[<{Argument ","}*>]>
	Argument.Identifier			= <<Identifier>>
	Argument.TypedIdentifier	= <( <Identifier> : <Type> )>
	
	Rules.Rules					= <"|"? {<Rule> "|"}*>
	
	Rule.Rule					= <<Pattern> -\> <Expression>>
	
	TypeDefinition.Type			= <"|"? {<Type> "|"}*>
	
	Type.Integer				= <int>
	Type.Boolean				= <bool>
	Type.Identifier				= <<Identifier>>
	Type.TypeIdentifier			= <<TypeConstIdentifier>>
	Type.List					= <<Type> list>
	Type.TypedIdentifier		= <<Identifier> of <Type>>
	Type.Tuple					= <{Type *}+>
	
	Pattern.Wildcard			= <_>
	Pattern.Concat				= <<Pattern> :: <Pattern>>
	Pattern.List				= <<ListPattern>>
	Pattern.Or					= <<Pattern> | <Pattern>>
	Pattern.Tuple				= <<Pattern> , <Pattern>>
	Pattern.Encapsulation		= <(<Pattern>)>
	Pattern.TypeConst			= <<TypeConstIdentifier> <Const?>>
	Pattern.TypeConstIdentifier	= <<TypeConstIdentifier> <Identifier?>>
	
	ListPattern.ListPattern		= <[<{Pattern ";"}*>]>
	