module MainClassModule
 
language minifsharp

start symbol Program

test main no statement [[
	class test { public static void main(String[] args) {} }
]] parse fails

test incomplete function [[
	[<EntryPoint>]
	let a
]] parse fails    

test incomplete recursive funtion [[
	[<EntryPoint>]
	let rec a
]] parse fails    

test incomplete match [[ 
	[<EntryPoint>]
	match 0 with 
]] parse fails  

test no entrypoint [[
	let x = 5;
]] parse fails  


test binop [[
	1+1 
	[<EntryPoint>]
	let x = 5
]] parse succeeds   

test binop with space [[
	1 * 1 
	[<EntryPoint>]
	let x = 5
]] parse succeeds

test minus [[
	1 - 1 
	[<EntryPoint>]
	let x = 5
]] parse succeeds  

test unop [[
	!true 
	[<EntryPoint>]
	let x = 5
]] parse succeeds     

test pattern matching: default; no leading bar [[
	match 0 with _ -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: default with leading bar [[
	match 0 with | _ -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match of variable [[
	match a with | _ -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match with const [[
	match a with | 0 -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match with list [[
	match a with | [1;2;3] -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match in var [[
	match a with | x -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match with list [[
	match a with | hd :: tl -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match with longer list [[
	match a with | hd :: neck :: tl -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match with simple tuple [[
	match a with | (1,2) -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test pattern matching: match with complex tuple [[
	match a with | (1,true,1::2, [1,2], (1,2,3)) -> true
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test typedefinition:  no leading bar [[
	type newType = C | A
	[<EntryPoint>]
	let x = 5
]] parse succeeds   

test typedefinition: leading bar [[
	type newType = | C | A
	[<EntryPoint>]
	let x = 5
]] parse succeeds    

test typedefinition: specify constructor type [[
	type newType = C | A of int
	[<EntryPoint>]
	let x = 5
]] parse succeeds   

test typedefinition: int list type [[
	type newType = C | A of int list
	[<EntryPoint>]
	let x = 5
]] parse succeeds   

test typedefinition: tuple type [[
	type newType = C | A of int * bool
	[<EntryPoint>]
	let x = 5
]] parse succeeds

test braces [[
	(1+1)*2
	[<EntryPoint>]
	let x = 5
]] parse succeeds

test braces2 [[
	[<EntryPoint>]
	let x = 1*2+3   
]] parse to minifsharp [[ 
	[<EntryPoint>]
	let x = (1*2)+3
]] 

test braces3 [[ 
	[<EntryPoint>]
	let x = (f g 0)
]] parse to minifsharp [[ 
	[<EntryPoint>]
	let x = ((f g) 0)
]]  

test braces4 [[ 
	[<EntryPoint>]
	let x = (a -b)
]] parse to minifsharp [[ 
	[<EntryPoint>]
	let x = (a (-b))
]]

test braces5 [[ 
	[<EntryPoint>]
	let x = (a-b)
]] parse to minifsharp [[ 
	[<EntryPoint>]
	let x = (a - b)
]]  

// disabled since they don't really need to parse to the same output;
// we can desugar it later
//test pattern matching optioinal leading bar [[ 
//	[<EntryPoint>]
//	match a with b -> true
//]] parse to minifsharp [[ 
//	[<EntryPoint>]
//	match a with |b -> true
//]]   

test FunctionDefinition incorrect [[
[<EntryPoint>]
let b 
= true
]] parse fails

test FunctionDefinition correct 1 [[
[<EntryPoint>]
let b
	= true
]] parse succeeds

test FunctionDefinition correct 2 [[
[<EntryPoint>]
let b = true
]] parse succeeds

test FunctionDefinition correct 3 [[
[<EntryPoint>]
let c = 
    let d =
     true
    true
]] parse succeeds

test FunctionDefinition nested correct [[
[<EntryPoint>]
let c = 
    let d =
     true
    true
]] parse succeeds

test FunctionDefinition nested incorrect [[
[<EntryPoint>]
let c = 
    let d =
    true
    true
]] parse fails

test binop on different lines [[
[<EntryPoint>]
let c = 
    1 +
    2
]] parse to minifsharp [[
[<EntryPoint>]
let c = 
    1 + 2
]]

test binop on different lines incorrect [[
[<EntryPoint>]
let c = 
    1 +
2
]] parse to minifsharp [[
[<EntryPoint>]
let c = 
    1 + 2
]]


